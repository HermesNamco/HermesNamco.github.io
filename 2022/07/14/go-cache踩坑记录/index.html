<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> go-cache踩坑记录 · Namco's blog</title><meta name="description" content="go-cache踩坑记录 - Namco"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://hermesnamco.github.io/atom.xml" title="Namco's blog"><meta name="generator" content="Hexo 6.2.0"><link rel="alternate" href="/atom.xml" title="Namco's blog" type="application/atom+xml">
</head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/HermesNamco" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">ABOUT</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">go-cache踩坑记录</h1><div class="post-info">2022年7月14日</div><div class="post-content"><h1 id="golang-memcache踩坑记录"><a href="#golang-memcache踩坑记录" class="headerlink" title="golang memcache踩坑记录"></a>golang memcache踩坑记录</h1><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>某后台业务使用memcache记录下辖节点信息状态，定期从某api拿到最新信息校验本地信息，定期dump进mysql数据库。<br>当节点心跳第一次到达时立即下发任务，否则按每12小时下发任务。</p>
<h2 id="故障"><a href="#故障" class="headerlink" title="故障"></a>故障</h2><p>后台运行过程中偶遇某些在线节点，突然被识别为初次达到心跳，故立即下发任务，造成任务下发量异常增加</p>
<h2 id="排查过程"><a href="#排查过程" class="headerlink" title="排查过程"></a>排查过程</h2><p>首先查日志，发现 mac&lt;。。。&gt; not found in cache，随后在mysql中发现写入的节点状态信息为空，未记录上次任务下发时间。<br>之后在日志中发现，在mac&lt;。。。&gt; not found in cache，发生了从某api拿信息校验与写入mysql数据库的过程，故怀疑被远端信息覆盖，导致本地信息被刷新为空。</p>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>整个过程起因于memcache清理过期信息的机制<br>这是cache结构体，使用map存储数据，并用锁控制并发读写操作，onEvicted为其删除后执行的处理函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">type cache struct &#123;</span><br><span class="line">    defaultExpiration time.Duration</span><br><span class="line">    items             map[string]Item</span><br><span class="line">    mu                sync.RWMutex</span><br><span class="line">    onEvicted         func(string, interface&#123;&#125;)</span><br><span class="line">    janitor           *janitor</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是一段memcache库中Delete的过程，发现当它去Delete时，拿到cache中的key和value的复制后，去执行onEvicted函数，我做判断后觉得是否重新加入cache中，但这一过程并未发生，就被远端数据覆盖了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// Delete an item from the cache. Does nothing if the key is not in the cache.</span><br><span class="line">func (c *cache) Delete(k string) &#123;</span><br><span class="line">	c.mu.Lock()</span><br><span class="line">	v, evicted := c.delete(k)</span><br><span class="line">	c.mu.Unlock()</span><br><span class="line">	if evicted &#123;</span><br><span class="line">		c.onEvicted(k, v)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">func (c *cache) delete(k string) (interface&#123;&#125;, bool) &#123;</span><br><span class="line">	if c.onEvicted != nil &#123;</span><br><span class="line">		if v, found := c.items[k]; found &#123;</span><br><span class="line">			delete(c.items, k)</span><br><span class="line">			return v.Object, true</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	delete(c.items, k)</span><br><span class="line">	return nil, false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是一段关于memcache.New()的解释。由于，memcache的过期数据清理并不是立即发生，而是一段间隔后检查一下进行清理，而导致主协程在拿到远端信息后认为本地不存在该节点信息，就将远端初始状态信息加入cache，而cache检查过期信息时，发现过期信息被刷新后没有过期，就未执行Delete函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Package:cache</span><br><span class="line">func New(defaultExpiration time.Duration, cleanupInterval time.Duration) *Cache</span><br><span class="line">Return a new cache with a given default expiration duration and cleanup interval. </span><br><span class="line">If the expiration duration is less than one (or NoExpiration), the items in the cache never expire (by default), and must be deleted manually. </span><br><span class="line">If the cleanup interval is less than one, expired items are not deleted from the cache before calling c.DeleteExpired().</span><br></pre></td></tr></table></figure>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><ol>
<li>在本场景中，节点信息数目较少，且长时间持有，可配置cache信息不过期，手工进行节点信息失效校验。</li>
<li>或采用手工Delete方式，应在过期后立即执行后续处理</li>
</ol>
</div></article></div></main><footer><div class="paginator"><a href="/2022/07/18/GRPC%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/" class="prev">上一篇</a><a href="/2022/07/14/hello-world/" class="next">下一篇</a></div><div class="copyright"><p>© 2015 - 2022 <a href="https://hermesnamco.github.io">Namco</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>